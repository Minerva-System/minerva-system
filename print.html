<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Minerva System</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introdução</a></li><li class="chapter-item expanded "><a href="estrutura.html"><strong aria-hidden="true">2.</strong> Estrutura geral do projeto</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> Front-End</div></li><li class="chapter-item expanded "><a href="backend.html"><strong aria-hidden="true">2.2.</strong> Back-End</a></li></ol></li><li class="chapter-item expanded "><a href="multi-tenancy.html"><strong aria-hidden="true">3.</strong> Multi-Tenancy</a></li><li class="chapter-item expanded "><a href="banco-relacional.html"><strong aria-hidden="true">4.</strong> Banco de Dados Relacional</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="migrations.html"><strong aria-hidden="true">4.1.</strong> Executando migrations</a></li></ol></li><li class="chapter-item expanded "><a href="banco-nao-relacional.html"><strong aria-hidden="true">5.</strong> Banco de Dados Não-Relacional</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="colecoes.html"><strong aria-hidden="true">5.1.</strong> Coleções</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Regras de Negócio</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentacao.html"><strong aria-hidden="true">6.1.</strong> Documentação do Projeto</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Cache de Sessão via Redis</div></li></ol></li><li class="chapter-item expanded "><a href="compilacao.html"><strong aria-hidden="true">7.</strong> Compilação</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="executar-maquina.html"><strong aria-hidden="true">7.1.</strong> Executar com recursos da máquina</a></li><li class="chapter-item expanded "><a href="gerando-imagens.html"><strong aria-hidden="true">7.2.</strong> Gerando imagens via Docker</a></li></ol></li><li class="chapter-item expanded "><a href="deploy.html"><strong aria-hidden="true">8.</strong> Deploy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deploy-compose.html"><strong aria-hidden="true">8.1.</strong> Deploy via Docker Compose</a></li><li class="chapter-item expanded "><a href="deploy-swarm.html"><strong aria-hidden="true">8.2.</strong> Deploy via Docker Swarm</a></li><li class="chapter-item expanded "><a href="deploy-kubernetes.html"><strong aria-hidden="true">8.3.</strong> Deploy via Kubernetes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Minerva System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introdução"><a class="header" href="#introdução">Introdução</a></h1>
<center>
<p><img src="./minerva-logo.png" alt="Logomarca do Sistema Minerva" /></p>
</center>
<p>Este documento trata da especificação funcional do Sistema Minerva. O sistema
é majoritariamente programado utilizando o método eXtreme Programming, portanto
esta documentação não é exaustiva no sentido de uma especificação completa,
posto que os requisitos do sistema estarão em constante mudança.</p>
<p>A modificação deste documento é enormemente encorajada, mas é mais importante a
prototipação constante do sistema que a escrita da especificação propriamente
dita.</p>
<p>Para mitigar os problemas que podem ocorrer mediante foco diminuído neste
documento, recomenda-se um grande uso de testes unitários e também de documentação
<em>ad-hoc</em> no código dos módulos do projeto, de preferência envolvendo as ferramentas
padrão da linguagem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estrutura-geral-do-projeto"><a class="header" href="#estrutura-geral-do-projeto">Estrutura geral do projeto</a></h1>
<p>O projeto Minerva é uma aplicação pensada com finalidade de estudo, mas que
não deixa de ser um sistema real e com um público alvo. Sendo assim, trata-se
de um sistema gerencial pensado para pequenos negócios, <em>sem finalidade comercial</em>.</p>
<p>O projeto envolve um licenciamento de Software Livre, e busca implementar uma
estrutura de microsserviços. Em outras palavras, o sistema opera através da modificação
de uma única base de dados, mas possui modulos separados para modificação de partes
específicas.</p>
<p>Minerva também utiliza uma dicotomia front-end/back-end, de forma que a aplicação
constitui-se de uma interface gráfica web, acessível via navegador, e uma intraestrutura
constituída de um ponto de entrada que se comunica com os serviços específicos que
a interface gráfica requisitar.</p>
<h2 id="serviços"><a class="header" href="#serviços">Serviços</a></h2>
<p>Como supracitado, Minerva constitui-se de microsserviços, especialmente em seu back-end.
Para tanto, deve-se pensar em três grandes serviços:</p>
<ul>
<li>Front-End (aplicação web envolvendo interface gráfica, feita em alguma tecnologia
para tal, como Flutter);</li>
<li>Back-End (aplicação com ponto de entrada REST, constituída de microsserviços, com
comunicação interna via gRPC);</li>
<li>Banco de Dados (PostgreSQL 14, que pode ser utilizado em um contêiner Docker para
intuitos de debug apenas).</li>
</ul>
<p>Adicionalmente, será possível manter uma maleabilidade que permita a confecção de outros
tipos de Front-Ends que se comuniquem diretamente com o Back-End da aplicação, como
por exemplo, através de programas nativos para Desktop e Mobile.</p>
<div><!-- Generated by graphviz version 2.43.0 (0)
 --><!-- Title: %3 Pages: 1 --><svg width="407pt" height="228pt"
 viewBox="0.00 0.00 407.00 228.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 224)"><title>%3</title><g id="clust2" class="cluster"><title>cluster_webservice</title><polygon fill="#666666" stroke="black" points="8,-98 8,-212 391,-212 391,-98 8,-98"/><text text-anchor="middle" x="199.5" y="-196.8" font-family="Times,serif" font-size="14.00">Serviço Web</text></g><g id="clust3" class="cluster"><title>cluster_internal</title><polygon fill="#999999" stroke="black" points="193,-106 193,-181 383,-181 383,-106 193,-106"/><text text-anchor="middle" x="288" y="-165.8" font-family="Times,serif" font-size="14.00">Interno</text></g><!-- frontend --><g id="node1" class="node"><title>frontend</title><polygon fill="lightgrey" stroke="black" points="145,-150 16,-150 16,-114 151,-114 151,-144 145,-150"/><polyline fill="none" stroke="black" points="145,-150 145,-144 "/><polyline fill="none" stroke="black" points="151,-144 145,-144 "/><text text-anchor="middle" x="83.5" y="-128.3" font-family="Times,serif" font-size="14.00">Front&#45;End (Web)</text></g><!-- backend --><g id="node2" class="node"><title>backend</title><polygon fill="lightgrey" stroke="black" points="285,-150 205,-150 201,-146 201,-114 281,-114 285,-118 285,-150"/><polyline fill="none" stroke="black" points="281,-146 201,-146 "/><polyline fill="none" stroke="black" points="281,-146 281,-114 "/><polyline fill="none" stroke="black" points="281,-146 285,-150 "/><text text-anchor="middle" x="243" y="-128.3" font-family="Times,serif" font-size="14.00">Back&#45;End</text></g><!-- frontend&#45;&#45;backend --><g id="edge3" class="edge"><title>frontend&#45;&#45;backend</title><path fill="none" stroke="darkorange" d="M151.29,-132C168.06,-132 185.57,-132 200.68,-132"/></g><!-- db --><g id="node3" class="node"><title>db</title><path fill="lightgrey" stroke="black" d="M375,-146.73C375,-148.53 362.9,-150 348,-150 333.1,-150 321,-148.53 321,-146.73 321,-146.73 321,-117.27 321,-117.27 321,-115.47 333.1,-114 348,-114 362.9,-114 375,-115.47 375,-117.27 375,-117.27 375,-146.73 375,-146.73"/><path fill="none" stroke="black" d="M375,-146.73C375,-144.92 362.9,-143.45 348,-143.45 333.1,-143.45 321,-144.92 321,-146.73"/><text text-anchor="middle" x="348" y="-128.3" font-family="Times,serif" font-size="14.00">BD</text></g><!-- backend&#45;&#45;db --><g id="edge4" class="edge"><title>backend&#45;&#45;db</title><path fill="none" stroke="darkmagenta" d="M285,-132C297.12,-132 310.05,-132 320.95,-132"/></g><!-- desktop --><g id="node4" class="node"><title>desktop</title><polygon fill="lightgrey" stroke="black" points="165,-90 2,-90 2,-54 165,-54 165,-90"/><text text-anchor="middle" x="83.5" y="-68.3" font-family="Times,serif" font-size="14.00">Front&#45;End (Desktop)</text></g><!-- desktop&#45;&#45;backend --><g id="edge1" class="edge"><title>desktop&#45;&#45;backend</title><path fill="none" stroke="darkorange" stroke-dasharray="5,2" d="M154.15,-90.13C157.84,-91.37 161.48,-92.66 165,-94 179.77,-99.61 195.52,-107.08 208.89,-113.92"/></g><!-- mobile --><g id="node5" class="node"><title>mobile</title><polygon fill="lightgrey" stroke="black" points="160,-36 7,-36 7,0 160,0 160,-36"/><text text-anchor="middle" x="83.5" y="-14.3" font-family="Times,serif" font-size="14.00">Front&#45;End (Mobile)</text></g><!-- mobile&#45;&#45;backend --><g id="edge2" class="edge"><title>mobile&#45;&#45;backend</title><path fill="none" stroke="darkorange" stroke-dasharray="5,2" d="M148.8,-36.08C154.47,-38.7 159.96,-41.66 165,-45 192.75,-63.38 216.71,-94.21 230.25,-113.8"/></g></g></svg></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="back-end"><a class="header" href="#back-end">Back-End</a></h1>
<p>O back-end Minerva compõe-se de microsserviços, com uma interface comum de
comunicação externa que seja simples de usar para os padrões atuais.</p>
<p>O back-end compõe-se dos seguintes componentes:</p>
<ol>
<li>Componente de comunicação externa: um serviço composto de rotas, sendo
portanto uma API REST. Este serviço requisita dados sob demanda a cada
serviço, dependendo do recurso que foi requisitado por via externa. É
efetivamente o intermediário entre Minerva e o mundo externo. As
requisições entre este serviço e os outros deverão ser feito através da
abertura de uma requisição gRPC em que este módulo seja o cliente
requisitante; as respostas recebidas via gRPC são então retornadas
como resposta às requisições recebidas via REST, após tratamento para
serialização como JSON.</li>
<li>Componente de usuários: Servidor gRPC responsável por realizar o CRUD
de usuários e por verificar as regras de negócio destas operações.</li>
<li>Componente de sessão: Servidor gRPC responsável por realizar login,
logoff, verificação de senha e gerenciamento de sessão de usuários.</li>
<li>Componente de produtos: Servidor gRPC responsável por realizar o CRUD
de produtos e por verificar as regras de negócio destas operações.</li>
<li>Componente de estoque: Servidor gRPC responsável por realizar regras
de negócios relacionadas a estoque de produtos (início, baixa, lançamento,
etc).</li>
</ol>
<p>Os <strong>serviços gRPC</strong> supracitados tratam-se de servidores gRPC que podem
receber conexões vindas do ponto de entrada REST ou mesmo entre si. Além
disso, os serviços gRPC devem ser capazes de se comunicar com bancos de
dados, que são recursos essenciais para os mesmos (exemplo: PostgreSQL,
Redis). Além disso, <strong>estes serviços devem gravar log de suas operações</strong>,
mais especificamente nas operações de inserção, atualização e exclusão.</p>
<p>Esses componentes possuem análogos programados, mas não são todos os módulos
da aplicação, que também constituem-se de bibliotecas que podem ser utilizadas
e referenciadas entre si.</p>
<div><!-- Generated by graphviz version 2.43.0 (0)
 --><!-- Title: %3 Pages: 1 --><svg width="512pt" height="393pt"
 viewBox="0.00 0.00 512.00 393.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 389)"><title>%3</title><g id="clust1" class="cluster"><title>cluster_db</title><polygon fill="transparent" stroke="darkmagenta" points="135,-8 135,-98 349,-98 349,-8 135,-8"/><text text-anchor="middle" x="242" y="-82.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">BANCO DE DADOS</text><text text-anchor="middle" x="242" y="-67.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">(multi&#45;tenant)</text></g><g id="clust3" class="cluster"><title>cluster_backend</title><polygon fill="transparent" stroke="darkred" points="8,-146 8,-308 496,-308 496,-146 8,-146"/><text text-anchor="middle" x="252" y="-292.8" font-family="Times,serif" font-size="14.00" fill="darkred">BACK&#45;END</text></g><!-- frontend --><g id="node1" class="node"><title>frontend</title><polygon fill="transparent" stroke="darkorange" points="236,-385 136,-385 136,-349 242,-349 242,-379 236,-385"/><polyline fill="none" stroke="darkorange" points="236,-385 236,-379 "/><polyline fill="none" stroke="darkorange" points="242,-379 236,-379 "/><text text-anchor="middle" x="189" y="-363.3" font-family="Times,serif" font-size="14.00" fill="darkorange">FRONT&#45;END</text></g><!-- rest --><g id="node5" class="node"><title>rest</title><polygon fill="#999999" stroke="green" points="217,-277 165,-277 161,-273 161,-241 213,-241 217,-245 217,-277"/><polyline fill="none" stroke="green" points="213,-273 161,-273 "/><polyline fill="none" stroke="green" points="213,-273 213,-241 "/><polyline fill="none" stroke="green" points="213,-273 217,-277 "/><text text-anchor="middle" x="189" y="-255.3" font-family="Times,serif" font-size="14.00" fill="green">REST</text></g><!-- frontend&#45;&#45;rest --><g id="edge11" class="edge"><title>frontend&#45;&#45;rest</title><path fill="none" stroke="green" d="M189,-348.97C189,-329.31 189,-297.13 189,-277.34"/><text text-anchor="middle" x="209" y="-319.8" font-family="Times,serif" font-size="14.00" fill="green">REST</text></g><!-- db2 --><g id="node2" class="node"><title>db2</title><path fill="#999999" stroke="darkmagenta" d="M341,-48.73C341,-50.53 328.9,-52 314,-52 299.1,-52 287,-50.53 287,-48.73 287,-48.73 287,-19.27 287,-19.27 287,-17.47 299.1,-16 314,-16 328.9,-16 341,-17.47 341,-19.27 341,-19.27 341,-48.73 341,-48.73"/><path fill="none" stroke="darkmagenta" d="M341,-48.73C341,-46.92 328.9,-45.45 314,-45.45 299.1,-45.45 287,-46.92 287,-48.73"/><text text-anchor="middle" x="314" y="-30.3" font-family="Times,serif" font-size="14.00" fill="darkmagenta">inq3</text></g><!-- db1 --><g id="node3" class="node"><title>db1</title><path fill="#999999" stroke="darkmagenta" d="M269,-48.73C269,-50.53 256.9,-52 242,-52 227.1,-52 215,-50.53 215,-48.73 215,-48.73 215,-19.27 215,-19.27 215,-17.47 227.1,-16 242,-16 256.9,-16 269,-17.47 269,-19.27 269,-19.27 269,-48.73 269,-48.73"/><path fill="none" stroke="darkmagenta" d="M269,-48.73C269,-46.92 256.9,-45.45 242,-45.45 227.1,-45.45 215,-46.92 215,-48.73"/><text text-anchor="middle" x="242" y="-30.3" font-family="Times,serif" font-size="14.00" fill="darkmagenta">inq2</text></g><!-- db3 --><g id="node4" class="node"><title>db3</title><path fill="#999999" stroke="darkmagenta" d="M197,-48.73C197,-50.53 184.9,-52 170,-52 155.1,-52 143,-50.53 143,-48.73 143,-48.73 143,-19.27 143,-19.27 143,-17.47 155.1,-16 170,-16 184.9,-16 197,-17.47 197,-19.27 197,-19.27 197,-48.73 197,-48.73"/><path fill="none" stroke="darkmagenta" d="M197,-48.73C197,-46.92 184.9,-45.45 170,-45.45 155.1,-45.45 143,-46.92 143,-48.73"/><text text-anchor="middle" x="170" y="-30.3" font-family="Times,serif" font-size="14.00" fill="darkmagenta">inq1</text></g><!-- user --><g id="node6" class="node"><title>user</title><polygon fill="#999999" stroke="blue" points="75.5,-190 20.5,-190 16.5,-186 16.5,-154 71.5,-154 75.5,-158 75.5,-190"/><polyline fill="none" stroke="blue" points="71.5,-186 16.5,-186 "/><polyline fill="none" stroke="blue" points="71.5,-186 71.5,-154 "/><polyline fill="none" stroke="blue" points="71.5,-186 75.5,-190 "/><text text-anchor="middle" x="46" y="-168.3" font-family="Times,serif" font-size="14.00" fill="blue">USER</text></g><!-- rest&#45;&#45;user --><g id="edge1" class="edge"><title>rest&#45;&#45;user</title><path fill="none" stroke="blue" d="M160.96,-246.22C146.85,-239.92 129.68,-231.69 115,-223 98.32,-213.13 80.65,-200.27 67.36,-190.06"/><text text-anchor="middle" x="135" y="-211.8" font-family="Times,serif" font-size="14.00" fill="blue">gRPC</text></g><!-- session --><g id="node7" class="node"><title>session</title><polygon fill="#999999" stroke="blue" points="178,-190 98,-190 94,-186 94,-154 174,-154 178,-158 178,-190"/><polyline fill="none" stroke="blue" points="174,-186 94,-186 "/><polyline fill="none" stroke="blue" points="174,-186 174,-154 "/><polyline fill="none" stroke="blue" points="174,-186 178,-190 "/><text text-anchor="middle" x="136" y="-168.3" font-family="Times,serif" font-size="14.00" fill="blue">SESSION</text></g><!-- rest&#45;&#45;session --><g id="edge2" class="edge"><title>rest&#45;&#45;session</title><path fill="none" stroke="blue" d="M178.27,-240.8C169.08,-226.05 155.9,-204.92 146.71,-190.18"/><text text-anchor="middle" x="185" y="-211.8" font-family="Times,serif" font-size="14.00" fill="blue">gRPC</text></g><!-- product --><g id="node8" class="node"><title>product</title><polygon fill="#999999" stroke="blue" points="287.5,-190 200.5,-190 196.5,-186 196.5,-154 283.5,-154 287.5,-158 287.5,-190"/><polyline fill="none" stroke="blue" points="283.5,-186 196.5,-186 "/><polyline fill="none" stroke="blue" points="283.5,-186 283.5,-154 "/><polyline fill="none" stroke="blue" points="283.5,-186 287.5,-190 "/><text text-anchor="middle" x="242" y="-168.3" font-family="Times,serif" font-size="14.00" fill="blue">PRODUCT</text></g><!-- rest&#45;&#45;product --><g id="edge3" class="edge"><title>rest&#45;&#45;product</title><path fill="none" stroke="blue" d="M199.73,-240.8C208.92,-226.05 222.1,-204.92 231.29,-190.18"/><text text-anchor="middle" x="238" y="-211.8" font-family="Times,serif" font-size="14.00" fill="blue">gRPC</text></g><!-- stock --><g id="node9" class="node"><title>stock</title><polygon fill="#999999" stroke="blue" points="374,-190 310,-190 306,-186 306,-154 370,-154 374,-158 374,-190"/><polyline fill="none" stroke="blue" points="370,-186 306,-186 "/><polyline fill="none" stroke="blue" points="370,-186 370,-154 "/><polyline fill="none" stroke="blue" points="370,-186 374,-190 "/><text text-anchor="middle" x="340" y="-168.3" font-family="Times,serif" font-size="14.00" fill="blue">STOCK</text></g><!-- rest&#45;&#45;stock --><g id="edge4" class="edge"><title>rest&#45;&#45;stock</title><path fill="none" stroke="blue" d="M217.14,-245.49C230.87,-239.14 247.51,-231.08 262,-223 280.26,-212.82 300.09,-200.08 315.19,-190.01"/><text text-anchor="middle" x="306" y="-211.8" font-family="Times,serif" font-size="14.00" fill="blue">gRPC</text></g><!-- report --><g id="node11" class="node"><title>report</title><polygon fill="#999999" stroke="blue" points="353,-277 279,-277 275,-273 275,-241 349,-241 353,-245 353,-277"/><polyline fill="none" stroke="blue" points="349,-273 275,-273 "/><polyline fill="none" stroke="blue" points="349,-273 349,-241 "/><polyline fill="none" stroke="blue" points="349,-273 353,-277 "/><text text-anchor="middle" x="314" y="-255.3" font-family="Times,serif" font-size="14.00" fill="blue">REPORT</text></g><!-- rest&#45;&#45;report --><g id="edge5" class="edge"><title>rest&#45;&#45;report</title><path fill="none" stroke="blue" d="M217.05,-259C234.04,-259 255.96,-259 274.67,-259"/><text text-anchor="middle" x="246" y="-265.8" font-family="Times,serif" font-size="14.00" fill="blue">gRPC</text></g><!-- user&#45;&#45;db1 --><g id="edge6" class="edge"><title>user&#45;&#45;db1</title><path fill="none" stroke="darkmagenta" d="M60.56,-153.84C74.76,-138.41 97.85,-116.59 123,-106 157.15,-91.62 174.88,-118.12 206,-98"/><text text-anchor="middle" x="143.5" y="-124.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">DB</text><text text-anchor="middle" x="143.5" y="-109.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">(Pool)</text></g><!-- session&#45;&#45;db1 --><g id="edge7" class="edge"><title>session&#45;&#45;db1</title><path fill="none" stroke="darkmagenta" d="M151.39,-153.76C163.49,-140.43 180.92,-121.65 197,-106 200.84,-102.27 202.63,-102.16 206,-98"/><text text-anchor="middle" x="217.5" y="-124.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">DB</text><text text-anchor="middle" x="217.5" y="-109.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">(Pool)</text></g><!-- product&#45;&#45;db1 --><g id="edge8" class="edge"><title>product&#45;&#45;db1</title><path fill="none" stroke="darkmagenta" d="M242,-153.78C242,-139.56 242,-118.48 242,-98"/><text text-anchor="middle" x="262.5" y="-124.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">DB</text><text text-anchor="middle" x="262.5" y="-109.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">(Pool)</text></g><!-- stock&#45;&#45;db1 --><g id="edge9" class="edge"><title>stock&#45;&#45;db1</title><path fill="none" stroke="darkmagenta" d="M327.2,-153.81C316.88,-140.33 301.71,-121.35 287,-106 283.3,-102.14 281.37,-102.16 278,-98"/><text text-anchor="middle" x="332.5" y="-124.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">DB</text><text text-anchor="middle" x="332.5" y="-109.8" font-family="Times,serif" font-size="14.00" fill="darkmagenta">(Pool)</text></g><!-- runonce --><g id="node10" class="node"><title>runonce</title><polygon fill="#999999" stroke="blue" points="487.5,-190 396.5,-190 392.5,-186 392.5,-154 483.5,-154 487.5,-158 487.5,-190"/><polyline fill="none" stroke="blue" points="483.5,-186 392.5,-186 "/><polyline fill="none" stroke="blue" points="483.5,-186 483.5,-154 "/><polyline fill="none" stroke="blue" points="483.5,-186 487.5,-190 "/><text text-anchor="middle" x="440" y="-168.3" font-family="Times,serif" font-size="14.00" fill="blue">RUNONCE</text></g><!-- runonce&#45;&#45;db1 --><g id="edge10" class="edge"><title>runonce&#45;&#45;db1</title><path fill="none" stroke="magenta" d="M424.02,-153.87C408.51,-138.47 383.49,-116.66 357,-106 324.26,-92.82 307.59,-117.23 278,-98"/><text text-anchor="middle" x="431" y="-124.8" font-family="Times,serif" font-size="14.00" fill="magenta">DB</text><text text-anchor="middle" x="431" y="-109.8" font-family="Times,serif" font-size="14.00" fill="magenta">(Avulsa)</text></g></g></svg></div>
<h2 id="bibliotecas"><a class="header" href="#bibliotecas">Bibliotecas</a></h2>
<p>As bibliotecas planejadas para o sistema são:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>minerva-rpc</code>: Implementação de protocolos gRPC e de mensagens destes
protocolo. Deve ser importado em todos os módulos, sendo essencial para
a criação de clientes e servidores gRPC. Os modelos de comunicação
implementados para si devem ser também convertidos para e
a partir dos DTOs do módulo de dados.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>minerva-data</code>: Implementação de utilitários de comunicação com banco de
dados (PostgreSQL) e objetos de transferência de dados (DTOs). Deve ser
importado em todos os módulos, exceto na comunicação REST. Os DTOs também
devem implementar traits e utilitários para conversão das mensagens
implementadas em <code>minerva-rpc</code> para os DTOs desta biblioteca.</li>
<li><input disabled="" type="checkbox"/>
<code>minerva-cache</code>: Implementação de utilitários de comunicação com
cache, message brokers e armazenamento temporário <em>in-memory</em> (Redis).
Deve ser importado principalmente no módulo de sessão.</li>
</ul>
<h2 id="módulos"><a class="header" href="#módulos">Módulos</a></h2>
<p>Os módulos planejados para o sistema são:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>minerva-user</code>: Servidor gRPC para CRUD de usuários. Deve ser capaz de
manipular as regras de negócios relacionadas a clientes.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>minerva-session</code>: Servidor gRPC para gerência de sessão de usuário.</li>
<li><input disabled="" type="checkbox"/>
<code>minerva-product</code>: Servidor gRPC para CRUD de produtos. Deve ser capaz
de manipular as regras de negócios relacionadas a produtos, mas que não
envolvam controle de estoque.</li>
<li><input disabled="" type="checkbox"/>
<code>minerva-stock</code>: Servidor gRPC para CRUD de estoque de produtos. Deve
ser capaz de manipular as regras de negócios relacionadas a estoque, mas
que não envolvam manipulação de produtos.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>minerva-rest</code>: Servidor REST para comunicação com os demais módulos
executáveis. Possui rotas que apontam para serviços específicos, e é por
definição um cliente gRPC de todos os servidores gRPC.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>minerva-runonce</code>: Serviço <strong>avulso</strong> para configuração do ambiente, de
forma assíncrona. Responsável pela execução de migrações do banco de dados
e outras operações de configuração inicial.</li>
<li><input disabled="" type="checkbox"/>
<code>minerva-report</code>: Servidor gRPC para geração de relatórios. Deve receber
dados com formatação esperada de um relatório, e então deverá gerar um
arquivo PDF e retorná-lo inteiramente como resposta.</li>
</ul>
<h2 id="portas"><a class="header" href="#portas">Portas</a></h2>
<p>Os serviços, independente de serem gRPC ou REST, devem ser executados em
certas portas padrão para evitarem conflitos durante o tempo de depuração.
Cada porta deve também ser configurável através de variáveis de ambiente.</p>
<p>A tabela a seguir discrimina as variáveis de ambiente e as portas padrão
de acordo com o serviço em questão.</p>
<table><thead><tr><th>Serviço</th><th>Variável</th><th>Valor</th></tr></thead><tbody>
<tr><td>USER</td><td><code>USER_SERVICE_PORT</code></td><td>9010</td></tr>
<tr><td>SESSION</td><td><code>SESSION_SERVICE_PORT</code></td><td>9011</td></tr>
<tr><td>PRODUCT</td><td><code>PRODUCT_SERVICE_PORT</code></td><td>9012</td></tr>
<tr><td>STOCK</td><td><code>STOCK_SERVICE_PORT</code></td><td>9013</td></tr>
<tr><td>REPORT</td><td><code>REPORT_SERVICE_PORT</code></td><td>9014</td></tr>
<tr><td>REST</td><td><code>ROCKET_PORT</code></td><td>9000</td></tr>
</tbody></table>
<p>No caso do serviço REST, verifique o arquivo <code>Rocket.toml</code> para avaliar
a configuração em desenvolvimento e em produção do mesmo.</p>
<h2 id="gateways"><a class="header" href="#gateways">Gateways</a></h2>
<p>Os serviços também podem operar em máquinas diferentes, dependendo de sua
rota.</p>
<p>Normalmente, quando todos os serviços são executados manualmente na mesma
máquina, operamos com uma rota <code>localhost</code>. Nesse caso, a variável de
ambiente de cada serviço é definida como esse valor.</p>
<p>Todavia, num ambiente de orquestração de contêineres (como Docker Compose
ou Kubernetes), cada serviço estará operando de forma separada, e poderá
comunicar-se com os outros serviços por intermédio de uma rede interna
ao qual apenas os serviços têm acesso de forma explícita. Assim, as
variáveis de ambiente que determinam o nome do servidor devem ser definidas
manualmente, de acordo com a forma como o deploy de cada serviço foi
realizado.</p>
<p>A seguir, temos uma tabela relacionando variáveis de ambiente com seus
devidos valores, que serão resolvidos através do DNS da rede interna criada
pelo orquestrador de contêineres.</p>
<p>No caso do serviço REST, verifique o arquivo <code>Rocket.toml</code> para avaliar
a configuração em desenvolvimento e em produção do mesmo.</p>
<table><thead><tr><th>Serviço</th><th>Variável</th><th>Valor em Produção</th></tr></thead><tbody>
<tr><td>USER</td><td><code>USER_SERVICE_SERVER</code></td><td><code>users</code></td></tr>
<tr><td>Banco de Dados Relacional</td><td><code>DATABASE_SERVICE_SERVER</code></td><td><code>postgresql</code></td></tr>
<tr><td>Banco de Dados Não-Relacional</td><td><code>MONGO_SERVICE_SERVER</code></td><td><code>mongodb</code></td></tr>
<tr><td>REST</td><td>nenhuma</td><td><code>rest</code></td></tr>
<tr><td>RUNONCE</td><td>nenhuma</td><td><code>runonce</code></td></tr>
<tr><td>SESSION</td><td><code>SESSION_SERVICE_SERVER</code></td><td><code>session</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-tenancy"><a class="header" href="#multi-tenancy">Multi-Tenancy</a></h1>
<p>O Sistema Minerva é um sistema <em>multi-tenant</em>. Isso significa que é
capaz de gerenciar bancos de dados diferentes dependendo do <em>tenant</em>
(cliente do serviço) atual. No Sistema Minerva, isso é gerenciado de
acordo com a forma como as requisições são recebidas.</p>
<h2 id="configuração"><a class="header" href="#configuração">Configuração</a></h2>
<p>Os tenants devem ser gerenciados através do arquivo <code>tenancy.toml</code>.</p>
<p>A seguir, um exemplo do conteúdo em potencial deste arquivo.</p>
<pre><code class="language-toml">[[tenants]]
name = &quot;Minerva System&quot;
database = &quot;minerva&quot;
connections = 5

[[tenants]]
name = &quot;Test Database&quot;
database = &quot;teste&quot;
connections = 5

[[tenants]]
name = &quot;Comercial Fulano S/A&quot;
database = &quot;comercial-fulano&quot;
connections = 5
</code></pre>
<h2 id="criação-dos-bancos-de-dados"><a class="header" href="#criação-dos-bancos-de-dados">Criação dos bancos de dados</a></h2>
<p>O serviço <code>RUNONCE</code> deverá executar a criação dos bancos de dados, caso
não seja possível conectar-se aos mesmos. Isso deve ser feito sobretudo
através da leitura do arquivo <code>tenancy.toml</code>, encontrado na pasta de
execução do projeto.</p>
<p>Caso um novo tenant seja adicionado ao sistema, o serviço <code>RUNONCE</code>
deverá ser forçadamente executado para que o sistema fique apto a
utilizar o banco de dados para aquele tenant.</p>
<p>O sistema <code>RUNONCE</code> deverá, para cada tenant listado em <code>tenancy.toml</code>:</p>
<ol>
<li>Tentar conectar-se aos bancos em questão. Se isso não for possível,
deverá criá-los;</li>
<li>Executar as migrations (no BD relacional) para aquele <em>tenant</em>;</li>
<li>Criar as coleções e índices (no BD não-relacional) para aquele <em>tenant</em>;</li>
<li>Criar o usuário <code>admin</code> (no BD relacional) para aquele <em>tenant</em>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="banco-de-dados-relacional"><a class="header" href="#banco-de-dados-relacional">Banco de Dados Relacional</a></h1>
<p>As próximas seções dizem respeito a partes relacionadas à estrutura do banco
de dados relacional (PostgreSQL) e a como modificá-la.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executando-migrations"><a class="header" href="#executando-migrations">Executando migrations</a></h1>
<p>As migrations são uma parte vital do Sistema Minerva, não apenas porque
definem as tabelas do banco de um <em>tenant</em>, mas porque também definem os
<em>schemas</em> para a programação dos módulos.</p>
<h2 id="pré-requisitos"><a class="header" href="#pré-requisitos">Pré-requisitos</a></h2>
<ul>
<li><a href="https://rustup.rs">Rust</a> (compilador <code>rustc</code> e gerenciador de
pacotes <code>cargo</code>, versão 1.60.0 ou superior);</li>
<li><a href="https://diesel.rs">Diesel</a> (versão 1.4.1 ou superior, com suporte
a PostgreSQL);</li>
<li><code>diesel_cli</code> com suporte a PostgreSQL;</li>
<li>Docker versão 20.10 ou superior.</li>
</ul>
<p>Para instalar o <code>diesel_cli</code> apenas com suporte a PostgreSQL, use o
seguinte comando:</p>
<pre><code class="language-bash">cargo install diesel_cli --no-default-feature --features postgres
</code></pre>
<h2 id="considerações-importantes"><a class="header" href="#considerações-importantes">Considerações importantes</a></h2>
<p><strong>Toda e qualquer migration deve ser criada no diretório do módulo
<code>minerva-runonce</code></strong>, especificamente porque este diretório possui também
as configurações de acesso e de geração de <em>schema</em> em
<code>minerva-data/src/schema.rs</code>.</p>
<p>Além disso, <strong>sempre execute todos os comandos abaixo no diretório do módulo
<code>minerva-runonce</code></strong>.</p>
<h2 id="configuração-inicial"><a class="header" href="#configuração-inicial">Configuração inicial</a></h2>
<p>Para começar, crie um contêiner Docker com o banco de dados:</p>
<pre><code class="language-bash">./make_docker_db.sh
</code></pre>
<p>Isso criará um contêiner com PostgreSQL 14 chamado <code>minerva-micro</code>. Caso o
contêiner já exista, veja mais abaixo como removê-lo.</p>
<p>Após a criação do contêiner, o processo de preparação do PostgreSQL pode
ser um pouco demorado. Acompanhe este processo observando os logs:</p>
<pre><code class="language-bash">docker logs -f minerva-micro
</code></pre>
<p>Em seguida, execute a operação inicial de criação de um banco de dados.
Para tanto, vamos criar um banco chamado <code>minerva</code> e executar todas as
migrations nele, logo de cara:</p>
<pre><code class="language-bash">diesel setup --database-url=&quot;postgres://postgres:postgres@localhost/minerva&quot;
</code></pre>
<h2 id="criando-uma-migration"><a class="header" href="#criando-uma-migration">Criando uma migration</a></h2>
<p>Para criar uma <em>migration</em>, use um comando similar ao seguinte:</p>
<pre><code class="language-bash">diesel migration generate &lt;nome_da_migration&gt;
</code></pre>
<p>Substitua <code>&lt;nome_da_migration&gt;</code> por um nome que faça sentido.
Isso gerará uma nova <em>migration</em> no diretório <code>migrations</code>,
que possuirá os arquivos <code>up.sql</code> e <code>down.sql</code>. Edite-os de acordo
com o necessário.</p>
<h2 id="executando-migrations-1"><a class="header" href="#executando-migrations-1">Executando migrations</a></h2>
<p>Para executar todas as <em>migrations</em> pendentes, execute o comando:</p>
<pre><code class="language-bash">diesel migration run --database-url=&quot;postgres://postgres:postgres@localhost/minerva&quot;
</code></pre>
<p>Isso também poderá reconstruir o arquivo <code>minerva-data/src/schema.rs</code>, a depender
de mudanças no <em>schema</em>.</p>
<p>Para testar a última migration executada:</p>
<pre><code class="language-bash">diesel migration redo --database-url=&quot;postgres://postgres:postgres@localhost/minerva&quot;
</code></pre>
<h2 id="removendo-banco-de-dados-de-teste"><a class="header" href="#removendo-banco-de-dados-de-teste">Removendo banco de dados de teste</a></h2>
<p>Para remover o banco de dados de teste criado no Docker, use os comandos a seguir.</p>
<p>Estes comandos servem para, respectivamente, parar a execução do contêiner e
então excluí-lo.</p>
<pre><code class="language-bash">docker stop minerva-micro
docker rm minerva-micro
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="banco-de-dados-não-relacional"><a class="header" href="#banco-de-dados-não-relacional">Banco de Dados Não-Relacional</a></h1>
<p>As próximas seções dizem respeito a partes relacionadas à estrutura do banco
de dados não-relacional (MongoDB) e a seu uso.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coleções"><a class="header" href="#coleções">Coleções</a></h1>
<p>Assim como no caso do banco de dados relacional, o banco de dados não-relacional
(criado através do MongoDB) também trabalha com um sistema <em>multi-tenant</em>, sendo
portanto representável como um banco de dados para cada cliente.</p>
<p>Ainda assim, para cada cliente, algumas coleções são essenciais de serem criadas
e configuradas até mesmo antes do primeiro acesso.</p>
<h2 id="coleção-session"><a class="header" href="#coleção-session">Coleção <code>session</code></a></h2>
<p>A coleção <code>session</code> armazena documentos contendo dados de sessão de um usuário.
A responsabilidade de armazenar dados dos usuários é do banco de dados relacional,
assim como a responsabilidade de autenticá-los é do serviço <code>SESSION</code>. Esta coleção,
todavia, armazena os dados de autenticação após a realização de um login válido.</p>
<p>Cada documento nesta coleção possui um tempo de expiração de uma semana, o que
alinha-se com o tempo máximo de uma sessão do usuário ser, igualmente, uma semana.
A gerência desse tempo de expiração se dá através de um campo <code>creationDate</code> no
documento, que armazena um <em>timestamp</em> indicando a data de início daquela sessão.
Caso o documento não possua esse campo, o MongoDB, por padrão, acaba não expirando-o.</p>
<p>A responsabilidade da definição e criação adequada do <code>creationDate</code> é do serviço
<code>SESSION</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentação-do-projeto"><a class="header" href="#documentação-do-projeto">Documentação do Projeto</a></h1>
<p>Esta seção contém links para a documentação das partes pertinentes ao código
do Minerva System.</p>
<p>Por padrão, a documentação é escrita em Inglês, e pode ser muito pertinente
durante a implementação de novas partes do sistema.</p>
<p>Não se esqueça de consultar estes documentos com frequência.</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<ul>
<li><a href="https://documenter.getpostman.com/view/17061755/Uyxoi4MU">Documentação da API</a><br />
Documentação da API REST (Postman, em Inglês).</li>
</ul>
<h2 id="serviços-externos"><a class="header" href="#serviços-externos">Serviços externos</a></h2>
<ul>
<li><a href="./doc/minerva_frontend/index.html">FRONTEND</a><br />
<em>Front-End</em> do Minerva System.</li>
<li><a href="./doc/minerva_rest/index.html">REST</a><br />
<em>Gateway</em> REST para acesso aos demais serviços.</li>
</ul>
<h2 id="microsserviços"><a class="header" href="#microsserviços">Microsserviços</a></h2>
<ul>
<li><a href="./doc/minerva_runonce/index.html">RUNONCE</a><br />
Utilitário de configuração inicial do sistema durante um deploy.</li>
<li><a href="./doc/minerva_session/index.html">SESSION</a><br />
Serviço de gerenciamento de sessão de usuário.</li>
<li><a href="./doc/minerva_user/index.html">USER</a><br />
Serviço de gerenciamento de usuários.</li>
<li>PRODUCT <em>(não implementado)</em></li>
<li>REPORT <em>(não implementado)</em></li>
<li>STOCK <em>(não implementado)</em></li>
</ul>
<h2 id="bibliotecas-1"><a class="header" href="#bibliotecas-1">Bibliotecas</a></h2>
<ul>
<li><a href="./doc/minerva_data/index.html">DATA</a><br />
Biblioteca de manipulação de DTOs e conversões de dados.</li>
<li><a href="./doc/minerva_rpc/index.html">RPC</a><br />
Biblioteca de implementação de Protocol Buffers, mensagens gRPC e afins.</li>
<li>CACHE <em>(não implementado)</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilação"><a class="header" href="#compilação">Compilação</a></h1>
<p>Este capítulo fala a respeito das formas de compilação do sistema.</p>
<p>Para compilar e executar a aplicação, vamos utilizar recursos da
máquina (em caso de situações envolvendo desenvolvimento) ou teste
de aplicação usando Docker.</p>
<p>A geração de imagens Docker é particularmente importante para a
realização de testes e deploy posteriores, o que será abordado
no próximo capítulo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilando-e-executando-com-recursos-da-máquina"><a class="header" href="#compilando-e-executando-com-recursos-da-máquina">Compilando e executando com recursos da máquina</a></h1>
<p>Você pode compilar os módulos do sistema individualmente e executá-los
usando o próprio ambiente Rust.</p>
<h2 id="introdução-1"><a class="header" href="#introdução-1">Introdução</a></h2>
<p>Este artigo trata da situação mais comum durante o desenvolvimento das
partes do sistema, que envolve utilizá-las individualmente em um
ambiente de desenvolvimento.</p>
<p>O <em>deploy</em> usando Docker Compose e Kubernetes, enquanto possível em
ambiente de homologação e de testes manuais, utiliza muitos recursos
da máquina, e não é o ideal de ser utilizado enquanto o programador
estiver debugando a aplicação. Além disso, pela própria forma como
o sistema foi planejado, é possível executar porções individuais do
sistema em que haja interdependência entre elas.</p>
<h2 id="objetivo"><a class="header" href="#objetivo">Objetivo</a></h2>
<p>Compilar todos os módulos ou módulos individuais é muito importante do
ponto de vista do desenvolvimento. Neste artigo, tratamos de como isso
pode ser feito na máquina local de um desenvolvedor.</p>
<h2 id="dependências"><a class="header" href="#dependências">Dependências</a></h2>
<p>Você precisará de:</p>
<ul>
<li><a href="https://rustup.rs">Rust</a> (compilador <code>rustc</code> e gerenciador de
pacotes <code>cargo</code>, versão 1.60.0 ou superior);</li>
<li><a href="https://diesel.rs">Diesel</a> (versão 1.4.1 ou superior, com suporte
a PostgreSQL);</li>
<li><a href="https://flutter.dev">Flutter</a> (versão 3.0.0 ou superior, canal
<code>stable</code>. Apenas necessário o <em>target</em> de compilação para <code>web</code>);</li>
<li>Dart (versão 2.17.0 ou superior, canal <code>stable</code>);</li>
<li>Docker (versão 2.10 ou superior).</li>
</ul>
<p>O compilador Rust e o Docker são essenciais para compilar os módulos
individuais do <em>back-end</em> do projeto, enquanto o Flutter é importante
para a confecção do <em>front-end</em> da aplicação. Sendo assim, as
dependências podem ser instaladas de acordo com o bom-senso do
desenvolvedor.</p>
<p>O Diesel pode ser instalado através do gerenciador de pacotes <code>cargo</code>,
e sua instalação pode ser consultada em seu site, linkado acima. Além
disso, a linguagem Dart será instalada através do Flutter, de acordo
com as instruções que podem ser encontradas no site do mesmo.</p>
<h2 id="estrutura-do-projeto"><a class="header" href="#estrutura-do-projeto">Estrutura do projeto</a></h2>
<!-- workspaces com projetos individuais, etc -->
<p>O repositório do projeto é um <em>monorepo</em>, isto é, engloba todas as
partes do sistema inteiro. Por isso, as partes relacionadas a <em>back-end</em>
estão dispostas em um <em>Workspace</em>, configurável através das próprias
ferramentas do <code>cargo</code> e da linguagem Rust, enquanto o <em>front-end</em>
encontra-se unicamente no diretório <code>minerva_frontend</code>, e não faz
parte do <em>Workspace</em> em si.</p>
<h2 id="preparação-do-ambiente"><a class="header" href="#preparação-do-ambiente">Preparação do ambiente</a></h2>
<p>A primeira parte a ser executada deverá ser a preparação do ambiente.
Isso inclui a preparação de quaisquer serviços ou bancos de dados
externos que possam ser importantes para a execução da aplicação.</p>
<p>No Sistema Minerva, o serviço <code>RUNONCE</code> é responsável por executar
essas operações, sendo também o serviço que executa <em>migrations</em> no
banco de dados, por exemplo.</p>
<p>Para tanto, precisaremos compilar este módulo específico antes de
qualquer outro. Isso será melhor delineado na seção sobre compilação
do <em>back-end</em>, mas realizaremos uma configuração rápida nesta seção.</p>
<h3 id="criando-o-banco-de-dados"><a class="header" href="#criando-o-banco-de-dados">Criando o banco de dados</a></h3>
<p>Como primeira dependência, recomenda-se criar o banco de dados via
Docker. Também seria possível instalar o PostgreSQL 14 na máquina local,
mas o Docker provê a comodidade necessária para o BD.</p>
<p>O diretório <code>minerva-runonce</code> possui um script que pode ser executado
para a criação do banco de dados. Este script executa o seguinte
comando:</p>
<pre><code class="language-bash">docker run --name minerva-micro \
       -e POSTGRES_USER=postgres \
       -e POSTGRES_PASSWORD=postgres \
       -p 5432:5432 \
       -d postgres:14
</code></pre>
<p>Este comando criará um contêiner chamado <code>minerva-micro</code>, a partir
da imagem Docker do PostgreSQL 14, com usuário e senhas padrão
<code>postgres</code>, e também servindo na porta <code>5432</code> da máquina atual (padrão
do PostgreSQL).</p>
<p>É importante lembrar que <strong>usar o contêiner dessa forma não é muito
seguro para persistência de dados</strong>. Por isso, <strong>pense neste contêiner
como um banco de dados de um ambiente exclusivo de testes.</strong></p>
<p>Caso você precise encerrar o contêiner, use:</p>
<pre><code class="language-bash">docker stop minerva-micro
</code></pre>
<p>Da mesma forma, não será necessário executar novamente o <code>RUNONCE</code> para
configuração, a não ser que o schema do banco de dados seja alterado.
Nesse caso, cada vez que for necessário reutilizar o banco para testes,
use o comando a seguir para reiniciar o BD:</p>
<pre><code class="language-bash">docker start minerva-micro
</code></pre>
<h3 id="executando-configuração-inicial-módulo-runonce"><a class="header" href="#executando-configuração-inicial-módulo-runonce">Executando configuração inicial (módulo <code>RUNONCE</code>)</a></h3>
<p>A seguir, execute o módulo <code>RUNONCE</code> para preparar todos os bancos de
dados de <em>tenants</em>, executar as migrations e criar o usuário <code>admin</code>
em cada banco.</p>
<p>Você poderá executar o módulo diretamente a partir da raiz do projeto:</p>
<pre><code class="language-bash">cargo run --bin minerva-runonce
</code></pre>
<p>Caso haja algum problema com o comando anterior (por exemplo, se o
módulo não encontrar o diretório <code>migrations</code>), vá para o diretório do
módulo e execute-o:</p>
<pre><code class="language-bash">cd minerva-runonce
cargo run
</code></pre>
<p>Após a compilação do módulo <code>RUNONCE</code>, o mesmo aguardará o banco de
dados estar pronto para receber as conexões e aplicará as migrations.</p>
<h2 id="compilação-back-end"><a class="header" href="#compilação-back-end">Compilação (<em>Back-end</em>)</a></h2>
<p>Você poderá compilar todos os módulos do projeto de uma só vez, ou
compilar apenas os módulos necessários.</p>
<h3 id="compilando-todos-os-módulos"><a class="header" href="#compilando-todos-os-módulos">Compilando todos os módulos</a></h3>
<p>Para compilar todos os módulos, vá para a raiz do projeto e execute
um comando de compilação para todo o workspace:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>De forma similar, você poderá compilar o projeto para produção através
da <em>flag</em> <code>--release</code>:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h3 id="compilando-um-módulo-específico"><a class="header" href="#compilando-um-módulo-específico">Compilando um módulo específico</a></h3>
<p>Existem duas formas de compilar um módulo específico: a partir do
<em>workspace</em> (diretório raiz do repositório) ou a partir do diretório
do módulo específico.</p>
<p>Qualquer módulo pode ser compilado a partir do diretório raiz com um
comando como o mostrado a seguir (substitua <code>&lt;módulo&gt;</code> pelo nome do
diretório do módulo em questão):</p>
<pre><code class="language-bash">cargo build --bin &lt;módulo&gt;
</code></pre>
<p>Isto compilará qualquer módulo que faça parte do <em>workspace</em>, exceto
bibliotecas auxiliares (como <code>minerva-rpc</code>, <code>minerva-data</code> e
<code>minerva-cache</code>) e o <em>front-end</em> (contido em <code>minerva_frontend</code>).</p>
<p>Da mesma forma, você também poderá ir ao diretório do módulo específico
e compilá-lo diretamente; neste caso, a compilação também funcionará
para bibliotecas auxiliares.</p>
<pre><code class="language-bash">cd &lt;módulo&gt;
cargo build
</code></pre>
<p>De forma similar à compilação geral, ambos os comandos também admitem
a <em>flag</em> <code>--release</code> para compilar os módulos para produção.</p>
<h3 id="execução"><a class="header" href="#execução">Execução</a></h3>
<p>É possível executar diretamente um módulo qualquer através do <code>cargo</code>,
o que também implica na sua compilação.</p>
<p>Para executar a partir do diretório do <em>workspace</em> (apenas para
módulos que geram executáveis):</p>
<pre><code class="language-bash">cargo run --bin &lt;módulo&gt;
</code></pre>
<p>Para executar a partir do diretório do módulo em questão:</p>
<pre><code class="language-bash">cd &lt;módulo&gt;
cargo run
</code></pre>
<p>Da mesma forma, é possível compilar e executar os módulos no modo
de produção através da <em>flag</em> <code>--release</code>.</p>
<h3 id="testes"><a class="header" href="#testes">Testes</a></h3>
<p>Para executar testes unitários e integração, basta seguir um processo
similar à execução dos módulos. Testes com binários compilados para
produção podem ser igualmente controlados pela <em>flag</em> <code>--release</code>.</p>
<p>Para executar quaisquer testes, é necessário <strong>garantir</strong> que o
banco de dados esteja acessível e adequadamente configurado.</p>
<pre><code class="language-bash"># Para testar todos os módulos do workspace
cargo test

# Para testar apenas um módulo do workspace
cargo test --bin &lt;módulo&gt;

# Para testar apenas um módulo em seu diretório
cd &lt;módulo&gt;
cargo test
</code></pre>
<h2 id="compilação-front-end"><a class="header" href="#compilação-front-end">Compilação (<em>Front-end</em>)</a></h2>
<p>O front-end é um módulo separado do restante dos módulos, sendo o
sistema que envolve a interface gráfica do Sistema Minerva.</p>
<h3 id="executando-o-projeto-via-console"><a class="header" href="#executando-o-projeto-via-console">Executando o projeto via console</a></h3>
<p>Para executar o projeto via console, basta usar a ferramenta de linha
de comando do Flutter.</p>
<h4 id="preparando-o-flutter"><a class="header" href="#preparando-o-flutter">Preparando o Flutter</a></h4>
<p>Antes de mais nada, garanta que o Flutter esteja configurado para
compilar projetos Web:</p>
<pre><code class="language-bash">flutter config --enable-web
</code></pre>
<p>Além disso, o Google Chrome deverá estar disponível para ser utilizado
no debug. O estado do ambiente Flutter pode ser verificado com o
comando <code>flutter doctor</code>.</p>
<p>Caso haja alguma inconsistência no seu ambiente, veja a seção de
<a href="https://docs.flutter.dev/get-started/web">preparação do Flutter para Web</a>
na documentação oficial.</p>
<h4 id="executando-o-projeto"><a class="header" href="#executando-o-projeto">Executando o projeto</a></h4>
<p>Para executar o projeto, vá até o diretório do módulo de <em>front-end</em>,
baixe as dependências necessárias, e então execute o projeto no Google
Chrome:</p>
<pre><code class="language-bash">cd minerva_frontend
flutter pub get
flutter run -d chrome
</code></pre>
<h3 id="compilando-para-produção"><a class="header" href="#compilando-para-produção">Compilando para produção</a></h3>
<p>Para compilar o projeto para produção, vá até a pasta do módulo e
execute os comandos a seguir. Eles baixarão as dependências faltantes
(caso já não tenham sido baixadas) e gerarão os arquivos estáticos
da aplicação.</p>
<pre><code class="language-bash">cd minerva_frontend
flutter pub get
flutter build web
</code></pre>
<p>Você poderá encontrar a versão compilada da aplicação <em>front-end</em> no
diretório <code>minerva_frontend/build/web</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gerando-imagens-via-docker"><a class="header" href="#gerando-imagens-via-docker">Gerando imagens via Docker</a></h1>
<h2 id="script-para-geração-de-imagens"><a class="header" href="#script-para-geração-de-imagens">Script para geração de imagens</a></h2>
<p>Já existe um script separado para a geração das imagens. Para gerá-las, vá até
a raiz do repositório e execute o comando:</p>
<pre><code class="language-bash">./generate_images.sh
</code></pre>
<p>Esse script foi especialmente feito para um console Bash, e pensado para
execução no Linux. No entanto, caso você esteja no Windows, poderá executá-lo
via Git Bash, MSYS2 ou similar, desde que seja possível utilizar o Docker
através da linha de comando.</p>
<h2 id="gerando-uma-imagem-em-específico"><a class="header" href="#gerando-uma-imagem-em-específico">Gerando uma imagem em específico</a></h2>
<p>Caso seja necessário, você poderá gerar uma imagem em específico de um projeto.</p>
<h3 id="projetos-rust"><a class="header" href="#projetos-rust">Projetos Rust</a></h3>
<p>Para qualquer projeto feito em Rust, poderá executar o seguinte comando a partir
da raiz do repositório:</p>
<pre><code class="language-bash">docker image build -f build/Dockerfile \
	--target minerva_&lt;projeto&gt; \
	-t seu_username/minerva_&lt;projeto&gt;:latest \
	.
</code></pre>
<p>Lembre-se de substituir <code>&lt;projeto&gt;</code> pelo projeto em questão.</p>
<h3 id="front-end"><a class="header" href="#front-end">Front-End</a></h3>
<p>Para gerar o front-end da aplicação, feito com Flutter, teremos que usar um
Dockerfile diferente:</p>
<pre><code class="language-bash">docker image build -f build/Dockerfile.frontend \
	-t seu_username/minerva_frontend:latest \
	.
</code></pre>
<h3 id="pgadmin-4"><a class="header" href="#pgadmin-4">PgAdmin 4</a></h3>
<p>A imagem com PgAdmin 4 é customizada com meros arquivos de configuração para
monitoramento do PostgreSQL. Por isso, também usa um Dockerfile diferente.</p>
<p>Veja também que ela é construída no diretório <code>build</code>.</p>
<pre><code class="language-bash">docker image build -f build/Dockerfile.pgadmin \
	-t seu_username/minerva_pgadmin:latest \
	build
</code></pre>
<h2 id="nomes-e-tags-das-imagens-geradas"><a class="header" href="#nomes-e-tags-das-imagens-geradas">Nomes e tags das imagens geradas</a></h2>
<p>As imagens geradas pelos passos anteriores são geradas com nomes
específicos. Esses nomes serão muito úteis do ponto de vista do
envio dessas imagens para o DockerHub e do deploy via Docker
Compose, Docker Swarm e Kubernetes.</p>
<p>As imagens são sempre geradas com a tag <code>latest</code>.</p>
<p>A seguir, temos uma tabela relacionando os serviços com os nomes e tags
das imagens geradas. Veja que elas se relacionam, inclusive, com a forma
como essas imagens encontram-se no DockerHub (sob o /username/ <code>luksamuk</code>):</p>
<table><thead><tr><th>Serviço</th><th>Nome e tag da imagem</th></tr></thead><tbody>
<tr><td><code>frontend</code></td><td><code>luksamuk/minerva_frontend:latest</code></td></tr>
<tr><td><code>rest</code></td><td><code>luksamuk/minerva_rest:latest</code></td></tr>
<tr><td><code>runonce</code></td><td><code>luksamuk/minerva_runonce:latest</code></td></tr>
<tr><td><code>users</code></td><td><code>luksamuk/minerva_users:latest</code></td></tr>
<tr><td><code>session</code></td><td><code>luksamuk/minerva_session:latest</code></td></tr>
<tr><td><code>pgadmin</code></td><td><code>luksamuk/minerva_pgadmin:latest</code></td></tr>
<tr><td><code>postgresql</code></td><td><code>postgres:14</code> (Não gerado)</td></tr>
<tr><td><code>mongodb</code></td><td><code>mongo:5</code> (Não gerado)</td></tr>
</tbody></table>
<h2 id="subindo-imagens-para-o-dockerhub"><a class="header" href="#subindo-imagens-para-o-dockerhub">Subindo imagens para o DockerHub</a></h2>
<p>Para enviar uma imagem para o DockerHub, primeiro é necessário se certificar de
que essa imagem possua uma <em>tag</em> adequada. Por exemplo, supondo que acabamos de
gerar a imagem com a <em>tag</em> 0.2.0 para o módulo <code>users</code>:</p>
<pre><code class="language-bash"># Faça algo similar para cada uma das imagens
docker image tag luksamuk/minerva_users luksamuk/minerva_users:0.2.0
</code></pre>
<p>Em seguida, poderemos enviar todas as tags das imagens para o DockerHub.</p>
<pre><code class="language-bash">docker image push -a luksamuk/minerva_frontend
docker image push -a luksamuk/minerva_rest
docker image push -a luksamuk/minerva_runonce
docker image push -a luksamuk/minerva_users
docker image push -a luksamuk/minerva_session
docker image push -a luksamuk/minerva_pgadmin
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy"><a class="header" href="#deploy">Deploy</a></h1>
<p>As sessões a seguir tratarão do deploy da aplicação, ou mais especificamente, de
formas escaláveis de subir a aplicação num ambiente que simule produção.</p>
<p>Este capítulo trata de três tipos específicos de deploy:</p>
<ul>
<li>Usando Docker Compose;</li>
<li>Usando Docker Swarm;</li>
<li>Usando Kubernetes, através do Minikube.</li>
</ul>
<p>O Docker Compose poderá ser utilizado em situações de teste e desenvolvimento,
especialmente porque seu arquivo de configuração sempre aponta para a imagem
com tag <code>latest</code> de todos os contêineres (o que significa que utilizará
as imagens que tiverem sido recém-geradas na máquina).</p>
<p>O Docker Swarm trabalha de forma similar ao Compose em sua configuração, porém
utilizaremos a ferramenta <code>docker stack</code>, além de certa configuração manual,
para subir um cluster com <code>docker-machine</code>, que pode também ser configurado de
forma doméstica. A configuração poderá então ser usada para orquestração de
contêineres.</p>
<p>Já o Kubernetes, utilizando uma máquina virtual KVM2 através do Minikube,
possibilita uma orquestração de contêineres ainda mais flexível. Esta configuração
é utilizada também para um ambiente local, mas será a forma mais próxima de
colocar o sistema em produção.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy-usando-docker-compose"><a class="header" href="#deploy-usando-docker-compose">Deploy usando Docker Compose</a></h1>
<center>
<img src="./docker-compose.png" alt="Docker Compose" width="350"/>
</center>
<p>Você pode realizar deploy do projeto usando Docker Compose. Todavia,
esta não é a forma mais recomendada de realização de deploy.</p>
<h2 id="introdução-2"><a class="header" href="#introdução-2">Introdução</a></h2>
<p>Docker Compose é uma ferramenta simples de orquestração de contêineres.
Para o Minerva System, é principalmente uma forma de <strong>testar</strong> a forma
como o serviço se comporta em rede.</p>
<h2 id="objetivo-1"><a class="header" href="#objetivo-1">Objetivo</a></h2>
<p>O deploy usando Docker Compose é útil principalmente do ponto de vista
da geração das imagens das aplicações dos microsserviços do Minerva
System, mas também não é a forma mais recomendada de colocar o sistema
em produção, porque não prevê fatores de escalabilidade como o deploy
usando Kubernetes.</p>
<p>Utilize esta forma principalmente quando quiser avaliar o comportamento
do sistema no que tange a interconexões entre os serviços numa rede
virtual.</p>
<h2 id="dependências-1"><a class="header" href="#dependências-1">Dependências</a></h2>
<p>Você precisará ter:</p>
<ul>
<li>Docker versão 20.10 ou superior;</li>
<li>Docker Compose versão 2.2.3 ou superior;</li>
<li>As imagens do projeto (se não estiverem localmente disponíveis,
serão baixadas).</li>
</ul>
<p>Além disso, <strong>todos os comandos a seguir devem ser executados no
diretório raiz deste projeto</strong>.</p>
<h2 id="executando-os-serviços"><a class="header" href="#executando-os-serviços">Executando os serviços</a></h2>
<p>Para executar os serviços usando Docker Compose, use o seguinte
comando:</p>
<pre><code class="language-bash">docker compose up
</code></pre>
<p>Caso você queira desligar o funcionamento dos serviços da sessão
atual do console, poderá executá-los em forma de <em>daemon</em>:</p>
<pre><code class="language-bash">docker compose up -d
</code></pre>
<p>Neste caso em específico, para <code>localhost</code>, estarão abertas as
seguintes portas para acesso:</p>
<table><thead><tr><th>Porta</th><th>Serviço</th></tr></thead><tbody>
<tr><td><code>80</code></td><td>Front-End</td></tr>
<tr><td><code>9000</code></td><td>API REST</td></tr>
<tr><td><code>8484</code></td><td>pgAdmin4</td></tr>
</tbody></table>
<h2 id="acompanhando-logs"><a class="header" href="#acompanhando-logs">Acompanhando logs</a></h2>
<p>Para acompanhar os logs de um deploy via <em>daemon</em> ou de um outro
console, você poderá realizá-lo através do comando:</p>
<pre><code class="language-bash">docker compose logs -f
</code></pre>
<p>Caso seja necessário acompanhar os logs de apenas um serviço:</p>
<pre><code class="language-bash">docker compose logs -f &lt;servico&gt;
</code></pre>
<p>Lembre-se de que o nome do serviço em questão deverá ser informado
como listado em <code>docker-compose.yml</code>.</p>
<h3 id="reiniciando-um-único-serviço"><a class="header" href="#reiniciando-um-único-serviço">Reiniciando um único serviço</a></h3>
<p>Você poderá reiniciar um único serviço, caso tenha recompilado a imagem
do mesmo, por exemplo.</p>
<p>Nesse caso, basta usar o seguinte comando:</p>
<pre><code class="language-bash">docker compose up -d --no-deps &lt;servico&gt;
</code></pre>
<p>Caso você queira incluir o passo de recompilação da imagem:</p>
<pre><code class="language-bash">docker compose up -d --no-deps --build &lt;servico&gt;
</code></pre>
<h2 id="encerrando-os-serviços"><a class="header" href="#encerrando-os-serviços">Encerrando os serviços</a></h2>
<p>Para encerrar imediatamente o serviço, execute o seguinte comando:</p>
<pre><code class="language-bash">docker compose down
</code></pre>
<p>Caso você queira também remover os volumes associados aos serviços
(por exemplo, nocaso do PostgreSQL e do pgAdmin), use este comando
em vez do anterior:</p>
<pre><code class="language-bash">docker compose -v down
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy-via-docker-swarm"><a class="header" href="#deploy-via-docker-swarm">Deploy via Docker Swarm</a></h1>
<center>
<img src="./docker-swarm.png" alt="Docker Swarm" width="200"/>
</center>
<p>Além do deploy via Docker Compose, também é possível disponibilizar a stack do
Sistema Minerva em um <em>cluster</em> do Docker Swarm.</p>
<p>Para tanto, é necessário inicializar o cluster. Isso pode ser feito, por
exemplo, com máquinas virtuais para finalidade de teste (neste caso, pode ser
utilizado o VirtualBox para prover essa facilidade).</p>
<h2 id="pré-requisitos-1"><a class="header" href="#pré-requisitos-1">Pré-requisitos</a></h2>
<ul>
<li>Docker Machine;</li>
<li>VirtualBox.</li>
</ul>
<h2 id="reinicializando-o-cluster"><a class="header" href="#reinicializando-o-cluster">Reinicializando o cluster</a></h2>
<p>Caso você já tenha construído um cluster e feito <em>deploy</em> anteriormente, é
bem provável que você não precise fazer a maioria do trabalho. Você poderá
simplesmente reiniciar as máquinas virtuais:</p>
<pre><code class="language-bash">docker-machine start `docker-machine ls &quot;minerva-*&quot; -q`
</code></pre>
<p>Existe a possibilidade de as máquinas virtuais não conseguirem se reconhecer
por uma mudança de IP. Se isso ocorrer, reconfigure o <em>cluster</em> manualmente,
gerando os <em>tokens</em> para cada máquina virtual e inserindo-as no <em>cluster</em>.</p>
<h2 id="criando-o-cluster"><a class="header" href="#criando-o-cluster">Criando o cluster</a></h2>
<p>Se você ainda não tiver um <em>cluster</em> criado, poderá criar o <em>cluster</em> através
da ferramenta Docker Machine. Comece criando uma máquina virtual chamada
<code>minerva-vm1</code>, que será nosso inicializador do <em>cluster</em>.</p>
<pre><code class="language-bash">docker-machine create -d virtualbox --swarm-master minerva-vm1
</code></pre>
<h3 id="iniciando-o-cluster"><a class="header" href="#iniciando-o-cluster">Iniciando o cluster</a></h3>
<p>Vamos começar iniciando o Docker Swarm na primeira máquina virtual.</p>
<p>Para acessar o console de uma máquina virtual via SSH, use também o Docker
Machine para isso.</p>
<pre><code class="language-bash">docker-machine ssh minerva-vm1
</code></pre>
<p>Para iniciar o cluster, precisamos descobrir também o IP dessa máquina virtual.
Você poderá ver o IP de uma máquina virtual em específico via Docker Machine
também, em outro console:</p>
<pre><code class="language-bash">docker-machine ip minerva-vm1
</code></pre>
<p>Voltando ao console da VM, vamos iniciar o Docker Swarm.</p>
<pre><code class="language-bash"># Em minerva-vm1
docker swarm init --advertise-addr &lt;IP&gt;
</code></pre>
<h3 id="criando-mais-managers"><a class="header" href="#criando-mais-managers">Criando mais managers</a></h3>
<p>Uma arquitetura básica de managers e workers do Swarm, para que o algoritmo de
consenso RAFT opere como esperado, poderia envolver três managers e dois workers
-- portanto, cinco máquinas virtuais.</p>
<p>Vamos criar mais duas máquinas virtuais que vão servir de managers (<code>minerva-vm2</code>
e <code>minerva-vm3</code>):</p>
<pre><code class="language-bash">docker-machine create -d virtualbox --swarm-master minerva-vm2
docker-machine create -d virtualbox --swarm-master minerva-vm3
</code></pre>
<p>Para adicionar essas VMs no <em>cluster</em>, vamos obter o token de entrada no <em>cluster</em>
para managers, que será um mero comando do console. Copiamos esse comando e colamos
no console das duas máquinas virtuais recém-criadas.</p>
<pre><code class="language-bash"># Em minerva-vm1
docker swarm join-token manager

# Em minerva-vm2 e minerva-vm3: Cole o comando
docker swarm join --token...
</code></pre>
<h3 id="criando-workers"><a class="header" href="#criando-workers">Criando workers</a></h3>
<p>Criaremos mais duas máquinas virtuais com o Swarm preparado, mas dessa vez, vamos
prepará-las para serem meros workers:</p>
<pre><code class="language-bash">docker-machine create -d virtualbox --swarm minerva-vm4
docker-machine create -d virtualbox --swarm minerva-vm5
</code></pre>
<p>O princípio para adicionar workers no <em>cluster</em> é o mesmo, porém usaremos um comando
diferente para gerar o token. Geramos esse comando, copiamos e colamos no console
das VMs <code>minerva-vm4</code> e <code>minerva-vm5</code>.</p>
<pre><code class="language-bash"># Em minerva-vm1
docker swarm join-token worker

# Em minerva-vm4 e minerva-vm5: Cole o comando
docker swarm join --token...
</code></pre>
<h3 id="verificando-a-topologia-do-cluster"><a class="header" href="#verificando-a-topologia-do-cluster">Verificando a topologia do cluster</a></h3>
<p>Vamos verificar a topologia do <em>cluster</em>. Podemos observar a atividade das máquinas
virtuais diretamente através do Docker Machine:</p>
<pre><code class="language-bash">docker-machine ls
</code></pre>
<pre><code>NAME          ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER      ERRORS
minerva-vm1   -        virtualbox   Running   tcp://192.168.99.108:2376           v19.03.12
minerva-vm2   -        virtualbox   Running   tcp://192.168.99.109:2376           v19.03.12
minerva-vm3   -        virtualbox   Running   tcp://192.168.99.110:2376           v19.03.12
minerva-vm4   -        virtualbox   Running   tcp://192.168.99.111:2376           v19.03.12
minerva-vm5   -        virtualbox   Running   tcp://192.168.99.112:2376           v19.03.12
</code></pre>
<p>Para avaliarmos o <em>cluster</em> em si e a forma como os nós se conectam, poderemos ver a
topologia dos nós diretamente dentro da primeira VM:</p>
<pre><code class="language-bash"># Em minerva-vm1
docker node ls
</code></pre>
<pre><code>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
exgmsiju6pnrl01tt33n5guui *   minerva-vm1         Ready               Active              Leader              19.03.12
cpxtnhalvu9tat9ek4n1n0117     minerva-vm2         Ready               Active              Reachable           19.03.12
p2v7v8ac93wuhwhcdsjl00p8y     minerva-vm3         Ready               Active              Reachable           19.03.12
jihrf6wgm145xzr0pdb6tnrck     minerva-vm4         Ready               Active                                  19.03.12
b1wfgme22m14pmjceo8ktn1hj     minerva-vm5         Ready               Active                                  19.03.12
</code></pre>
<p>Outra opção interessante é acompanhar também os serviços e os contêineres criados:</p>
<pre><code class="language-bash"># Em minerva-vm1
docker service ls
docker container ls
</code></pre>
<h3 id="fazendo-backup-do-cluster"><a class="header" href="#fazendo-backup-do-cluster">Fazendo backup do cluster</a></h3>
<p>Caso você queira fazer backup da topologia do <em>cluster</em>, lembre-se de copiar o
diretório <code>/var/lib/docker/swarm</code> em <code>minerva-vm1</code>.</p>
<pre><code class="language-bash"># Em minerva-vm1
sudo cp -r /var/lib/docker/swarm ./swarm
sudo chown -R $USER ./swarm

# No host
docker-machine scp -r minerva-vm1:/home/docker/swarm localhost:~/swarm-backup
</code></pre>
<h2 id="fazendo-deploy-do-sistema-minerva"><a class="header" href="#fazendo-deploy-do-sistema-minerva">Fazendo deploy do Sistema Minerva</a></h2>
<p>Para fazer <em>deploy</em> do sistema, dado que o <em>cluster</em> esteja configurado, basta
reutilizar o arquivo preparado para isso no repositório do Sistema Minerva.</p>
<p>Copiamos o arquivo para dentro da VM principal e então realizamos deploy:</p>
<pre><code class="language-bash">docker-machine scp localhost:./docker-stack.yml minerva-vm1:/home/docker/docker-stack.yml

# Em minerva-vm1
docker stack deploy --compose-file docker-stack.yml minerva-system
</code></pre>
<h3 id="gerenciando-a-stack"><a class="header" href="#gerenciando-a-stack">Gerenciando a stack</a></h3>
<p>Podemos gerenciar a stack facilmente dentro de uma VM manager.</p>
<p>Para listar as stacks ativas:</p>
<pre><code class="language-bash"># Em minerva-vm1
docker stack ls
</code></pre>
<p>Se quisermos observar os serviços de uma stack em específico:</p>
<pre><code class="language-bash"># Em minerva-vm1
docker stack services minerva-system
</code></pre>
<p>Ou, em último caso, se quisermos remover uma stack:</p>
<pre><code class="language-bash"># Em minerva-vm1
docker stack rm minerva-system
</code></pre>
<h3 id="acessando-os-serviços"><a class="header" href="#acessando-os-serviços">Acessando os serviços</a></h3>
<p>Para visualizar os serviços, primeiro visualize o IP das Docker Machines:</p>
<pre><code class="language-bash">docker-machine ls
</code></pre>
<p>É possível usar o IP de qualquer Docker Machine, neste ponto. Basta utilizar
as portas certas:</p>
<table><thead><tr><th>Porta</th><th>Descrição</th></tr></thead><tbody>
<tr><td>80</td><td>Front-end</td></tr>
<tr><td>9000</td><td>API REST</td></tr>
<tr><td>8484</td><td>PgAdmin 4</td></tr>
<tr><td>8585</td><td>Visualizador do cluster</td></tr>
</tbody></table>
<h2 id="encerrando-o-serviço"><a class="header" href="#encerrando-o-serviço">Encerrando o serviço</a></h2>
<p>Caso você queira parar todas as máquinas virtuais, use o comando a seguir.</p>
<pre><code class="language-bash">docker-machine stop `docker-machine ls &quot;minerva-*&quot; -q`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy-usando-kubernetes-e-minikube"><a class="header" href="#deploy-usando-kubernetes-e-minikube">Deploy usando Kubernetes (e Minikube)</a></h1>
<center>
<img src="./kubernetes-logo.webp" alt="Kubernetes" width="200"/>
</center>
<p>Você pode realizar deploy do projeto usando Kubernetes. Nos passos a
seguir, será mostrado como realizar um deploy usando a ferramenta
Minikube, para instalação do Kubernetes localmente.</p>
<p><strong>ATENÇÃO:</strong> Para detalhes não dispostos nesta página, veja a
<a href="https://kubernetes.io/docs/home/">documentação oficial do Kubernetes</a>.</p>
<h2 id="introdução-3"><a class="header" href="#introdução-3">Introdução</a></h2>
<p>Kubernetes é uma ferramenta sofisticada de orquestração de contêineres.
O Minerva System é planejado para que seu deploy seja feito utilizando
o Kubernetes.</p>
<p>Para realizar a configuração localmente, fui utilizada a ferramenta
Minikube. Portanto, os comandos aqui abordados partem do pressuposto
de uma instalação local do Kubernetes via Minikube, e podem ser </p>
<h2 id="objetivo-2"><a class="header" href="#objetivo-2">Objetivo</a></h2>
<p>O deploy usando Kubernetes é planejado desde o início do projeto, sendo
uma das formas de estado da arte de deploy de aplicações web. Para
simular este cenário, utilizamos uma instalação local do Kubernetes
via Minikube.</p>
<p>Ainda que Minikube não seja exatamente um servidor do Kubernetes em
produção, boa parte do que será aqui discutido poderá ser utilizado
no momento do deploy para produção.</p>
<h2 id="dependências-2"><a class="header" href="#dependências-2">Dependências</a></h2>
<p>Você precisará ter instalado:</p>
<ul>
<li>Docker versão 20.10 ou superior;</li>
<li>Docker Compose versão 2.2.3 ou superior;</li>
<li>Kubectl versão 1.23.3 ou superior;</li>
<li><a href="https://minikube.sigs.k8s.io/docs/">Minikube</a> versão 1.24.0 ou
superior;</li>
<li><a href="k9scli.io">k9s</a> versão 0.25.18 ou superior (opcional).</li>
</ul>
<p>A instalação do k9s é opcional, sendo uma ferramenta de monitoramento
e gerencialmento do Kubernetes via linha de comando.</p>
<h3 id="iniciando-o-minikube"><a class="header" href="#iniciando-o-minikube">Iniciando o Minikube</a></h3>
<p>Caso você esteja testando localmente, comece executando o Minikube.</p>
<p>As configurações a seguir iniciam um cluster local via Minikube, usando
KVM2 como backend. Você poderá também usar os backends <code>docker</code> ou
<code>virtualbox</code>, à escolha.</p>
<pre><code class="language-bash">minikube start \
	--vm-driver=kvm2 \
	--disable-optimizations=false \
	--extra-config=kubelet.housekeeping-interval=10s

minikube addons enable metrics-server
</code></pre>
<p>Se você quiser parar o Minikube:</p>
<pre><code class="language-bash">minikube stop
</code></pre>
<p>Igualmente, se quiser remover o cluster:</p>
<pre><code class="language-bash">minikube delete --all
</code></pre>
<h3 id="problemas-com-libvirt-e-apparmor"><a class="header" href="#problemas-com-libvirt-e-apparmor">Problemas com Libvirt e AppArmor</a></h3>
<p>Caso você tenha problemas para inicializar a máquina virtual com KVM2,
pode ser que sua instalação local do AppArmor esteja interferindo com
o <code>libvirt</code>.</p>
<p>Como ferramenta paliativa à configuração do AppArmor para o <code>libvirt</code>,
você poderá colocar os utilitários usados pelo Minikube no modo <em>complain</em>.
Lembre-se de que isso é necessariamente detrimental à segurança do sistema.</p>
<pre><code class="language-bash">sudo aa-complain /usr/sbin/libvirtd
sudo aa-complain /usr/libexec/virt-aa-helper
</code></pre>
<h2 id="estrutura-do-cluster"><a class="header" href="#estrutura-do-cluster">Estrutura do Cluster</a></h2>
<p>A seguir, trataremos da estrutura do cluster como atualmente é definido.
As seções a seguir tratam sempre de objetos específicos do Kubernetes,
e são também uma sugestão de ordem de aplicação dos arquivos de configuração.</p>
<p>Todos os arquivos serão encontrados de forma homônima no diretório <code>deploy</code>,
com a extensão <code>yml</code>.</p>
<p>Caso queira aplicar todos os arquivos enumerados abaixo, simplesmente execute:</p>
<pre><code class="language-bash">kubectl apply -f deploy
</code></pre>
<h3 id="configmaps"><a class="header" href="#configmaps"><em>ConfigMaps</em></a></h3>
<p>Um <em>ConfigMap</em> é um objeto que armazena dados que serão utilizados como
variáveis de ambiente de um <em>pod</em>.</p>
<ul>
<li><code>postgresql-configmap</code>: Variáveis padrão para definições iniciais do
PostgreSQL 14.</li>
<li><code>mongodb-configmap</code>: Variáveis padrão para definições iniciais do
MongoDB 5.</li>
<li><code>runonce-configmap</code>: Variáveis padrão para definições iniciais do
Job RUNONCE.</li>
<li><code>frontend-configmap</code>: Variáveis padrão para uso do Front-End.</li>
<li><code>rest-configmap</code>: Variáveis padrão para a API REST.</li>
<li><code>ports-configmap</code>: Portas para acesso aos serviços no cluster.</li>
<li><code>servers-configmap</code>: Nomes dos serviços a serem acessados. Geralmente
associados a cada Deployment ou StatefulSet.</li>
</ul>
<p>Para aplicar todos os <em>ConfigMaps</em>, execute:</p>
<pre><code class="language-bash">for f in `ls deploy/*-configmap.yml`; do kubectl apply -f $f; done
</code></pre>
<h3 id="persistentvolumeclaims"><a class="header" href="#persistentvolumeclaims"><em>PersistentVolumeClaims</em></a></h3>
<p>Um <em>PersistentVolumeClaim</em> age como uma reserva de volume persistente
(<em>PersistentVolume</em>). Pode associar-se a um volume que exista ou, neste
caso, cria um volume com tamanho específico dinamicamente.</p>
<ul>
<li><code>postgresql-pvc</code>: PersistentVolumeClaim para o PostgreSQL. Solicita 1GB
de armazenamento e criação dinâmica.</li>
<li><code>mongodb-pvc</code>: PersistentVolumeClaim para o MongoDB. Solicita 1GB de
armazenamento e criação dinâmica.</li>
</ul>
<p>Para aplicar todos os <em>PersistentVolumeClaims</em>, execute:</p>
<pre><code class="language-bash">for f in `ls deploy/*-pvc.yml`; do kubectl apply -f $f; done
</code></pre>
<h3 id="deployments"><a class="header" href="#deployments"><em>Deployments</em></a></h3>
<p>Um <em>Deployment</em> é uma forma de gerenciar <em>pods</em> e suas réplicas. Mais
especificamente, trata-se de uma evolução de um <em>ReplicaSet</em> que permite
a utilização de versionamento.</p>
<ul>
<li><code>postgresql-deployment</code>: Deployment para o banco de dados PostgreSQL.</li>
<li><code>mongodb-deployment</code>: Deployment para o banco de dados MongoDB.</li>
<li><code>frontend-deployment</code>: Deployment para o Front-End Web do sistema.</li>
<li><code>rest-deployment</code>: Deployment para o gateway REST do sistema.</li>
<li><code>users-deployment</code>: Deployment para o microsserviço <code>USERS</code>.</li>
<li><code>session-deployment</code>: Deployment para o microsserviço <code>SESSION</code>.</li>
</ul>
<p>Para aplicar todos os <em>Deployments</em>, execute:</p>
<pre><code class="language-bash">for f in `ls deploy/*-deployment.yml`; do kubectl apply -f $f; done
</code></pre>
<h3 id="services"><a class="header" href="#services"><em>Services</em></a></h3>
<p>Um <em>Service</em> determina a conexão de um ou mais <em>pods</em> com o restante do
cluster ou com a internet. <em>Services</em> podem ser do tipo <em>ClusterIP</em>,
<em>NodePort</em> ou <em>LoadBalancer</em>. O primeiro tipo expõe os <em>pods</em> apenas para
outros <em>pods</em> do cluster; o segundo e o terceiro expõem para a internet,
com a diferença que um <em>LoadBalancer</em> é a maneira padrão de exposição por
integrar-se com o balanceador de recursos do provedor do cluster.</p>
<p>Além disso, serviços do tipo <em>LoadBalancer</em> agem retroativamente como
<em>NodePort</em>, e estes agem também retroativamente como <em>ClusterIP</em>.</p>
<ul>
<li><code>postgresql-svc</code> (<em>ClusterIP</em>): Serviço para acesso interno aos pods
PostgreSQL.</li>
<li><code>mongodb-svc</code> (<em>ClusterIP</em>): Serviço para acesso interno aos pods
MongoDB.</li>
<li><code>users-svc</code> (<em>ClusterIP</em>): Serviço para acesso interno aos pods do
microsserviço USERS.</li>
<li><code>session-svc</code> (<em>ClusterIP</em>): Serviço para acesso interno aos pods do
microsserviço SESSION.</li>
<li><code>frontend-svc</code> (<em>LoadBalancer</em>): Serviço para acesso interno e externo
aos pods do Front-End Web do sistema. Exposto na porta <code>30001</code>.</li>
<li><code>rest-svc</code> (<em>LoadBalancer</em>): Serviço para acesso interno e externo aos
pods do gateway REST do sistema. Exposto na porta <code>30000</code>.</li>
</ul>
<p>Para aplicar todos os <em>Services</em>, execute:</p>
<pre><code class="language-bash">for f in `ls deploy/*-svc.yml`; do kubectl apply -f $f; done
</code></pre>
<h3 id="jobs"><a class="header" href="#jobs"><em>Jobs</em></a></h3>
<p>Um <em>Job</em> é responsável por criar um <em>pod</em> que executará alguma ação, até
seu completamento ser realizado com sucesso.</p>
<ul>
<li><code>runonce-job</code>: Job a ser executado no início do deploy do cluster, para
configuração inicial. Reiniciará o <em>pod</em> em caso de falhas dez vezes e,
após sucesso, será removido junto com o <em>pod</em> após cinco minutos.</li>
</ul>
<p>Para aplicar todos os <em>ConfigMaps</em>, execute:</p>
<pre><code class="language-bash">for f in `ls deploy/*-job.yml`; do kubectl apply -f $f; done
</code></pre>
<h3 id="horizontalpodautoscalers"><a class="header" href="#horizontalpodautoscalers">HorizontalPodAutoscalers</a></h3>
<ul>
<li><code>rest-hpa</code>: Escalonador horizontal do gateway REST. Mantém entre 1 e
15 réplicas para <code>rest-deployment</code> com uso médio de 50% do CPU alocado.</li>
<li><code>users-hpa</code>: Escalonador horizontal do microsserviço USERS. Mantém entre
2 e 6 réplicas para <code>users-deployment</code> com uso médio de 65% do CPU alocado.</li>
<li><code>session-hpa</code>: Escalonador horizontal do microsserviço SESSION. Mantém
entre 2 e 6 réplicas para <code>session-deployment</code> com uso médio de 65%
do CPU alocado.</li>
</ul>
<p>Para aplicar todos os <em>HorizontalPodAutoscalers</em>, execute:</p>
<pre><code class="language-bash">for f in `ls deploy/*-hpa.yml`; do kubectl apply -f $f; done
</code></pre>
<h3 id="ingresses"><a class="header" href="#ingresses"><em>Ingresses</em></a></h3>
<p>Um <em>Ingress</em> é um objeto responsável por gerenciar acesso externo a
serviços no cluster, tipicamente via HTTP.</p>
<ul>
<li><code>api-ingress</code>: Ponto de entrada para a API através do URL
<code>http://minerva-system.io</code>. Expõe a API em <code>/api</code>.</li>
<li><code>frontend-ingress</code>: Ponto de entrada para o Front-End através do URL
<code>http://minerva-system.io</code>. Expõe o Front-End em <code>/</code>.</li>
</ul>
<p>Para aplicar todos os <em>Ingresses</em>, execute:</p>
<pre><code class="language-bash">for f in `ls deploy/*-ingress.yml`; do kubectl apply -f $f; done
</code></pre>
<h2 id="acesso-via-nodeport"><a class="header" href="#acesso-via-nodeport">Acesso via NodePort</a></h2>
<p>Para acessar os serviços expostos via <em>NodePort</em> (ou <em>LoadBalancer</em>) no
cluster, diretamente através do IP do Minikube, primeiramente verifique
o endereço IP do cluster. Isso pode ser feito via Kubectl:</p>
<pre><code class="language-bash">kubectl get node -o wide
</code></pre>
<p>Isso pode também ser feito através do Minikube:</p>
<pre><code class="language-bash">minikube ip
</code></pre>
<p>Você poderá acessar os serviços através deste mesmo IP, através das portas
<code>30000</code> (API REST) ou <code>30001</code> (Front-End).</p>
<h2 id="acesso-via-ingress"><a class="header" href="#acesso-via-ingress">Acesso via Ingress</a></h2>
<p>Outra forma de acessar envolve o uso dos objetos <em>Ingress</em>. Isso nos
permitirá usar o endereço <code>http://minerva-system.io/</code> como URL base
do sistema.</p>
<p>Primeiramente, habilite o addon <code>ingress</code> no Minikube:</p>
<pre><code class="language-bash">minikube addons enable ingress
</code></pre>
<p>Agora, descubra o IP do Minikube na máquina:</p>
<pre><code class="language-bash">minikube ip
</code></pre>
<p>Finalmente, edite o arquivo <code>/etc/hosts</code> e adicione o seguinte:</p>
<pre><code>&lt;ip-do-minikube&gt;	minerva-system.io
</code></pre>
<p>O Front-End agora poderá ser acessado em <code>http://minerva-system.io/</code>,
e a API poderá ser acessada em <code>http://minerva-system.io/api</code>.</p>
<h2 id="monitorando-via-k9s"><a class="header" href="#monitorando-via-k9s">Monitorando via k9s</a></h2>
<p><img src="./k9s.png" alt="k9s" /></p>
<p>Uma das ferramentas possíveis de se utilizar para monitorar o cluster
é o <code>k9s</code>.</p>
<p>A ferramenta utiliza uma edição modal, muito parecida com o editor
Vim. Os comandos possuem um sistema de autocompletar e são também
mostrados na tela. Alguns comandos interessantes de serem utilizados
são:</p>
<ul>
<li><code>:q</code>: Sair da aplicação.</li>
<li><code>:po</code>: Lista de <em>Pods</em>.</li>
<li><code>:svc</code>: Lista de <em>Services</em>.</li>
<li><code>:dp</code>: Lista de <em>Deployments</em>.</li>
<li><code>:ing</code>: Lista de <em>Ingresses</em>.</li>
<li><code>:hpa</code>: Lista de <em>HorizontalPodAutoscalers</em>.</li>
<li><code>:pvc</code>: Lista de <em>PersistentVolumeClaims</em>.</li>
<li><code>:pv</code>: Lista de <em>PersistentVolumes</em>.</li>
</ul>
<p>Você poderá usar o <code>k9s</code> para visualizar logs e também para modificar
algumas propriedades mais avançadas também. É possível até mesmo acessar
diretamente o console dos contêineres.</p>
<h2 id="monitorando-via-dashboard"><a class="header" href="#monitorando-via-dashboard">Monitorando via dashboard</a></h2>
<p>Você também pode acessar facilmente um dashboard web do Kubernetes,
operando sob o Minikube, caso não queira usar o <code>k9s</code> posteriormente
(lembre-se de que objetos como <em>HorizontalPodAutoscaler</em> não são
visíveis nesse Dashboard):</p>
<pre><code class="language-bash">minikube dashboard
</code></pre>
<h2 id="testes-de-stress"><a class="header" href="#testes-de-stress">Testes de Stress</a></h2>
<p>Para realizar testes de stress, use o script <code>deploy/stress_test.sh</code>.
Você poderá testar cada sistema crucial usando um comando como este:</p>
<pre><code class="language-bash">./deploy/stress_test.sh minerva-system.io/api users
</code></pre>
<p>Para maiores informações, execute o script sem argumentos.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
